import torch
from torch import Tensor
import torch.nn as nn
from annoy import AnnoyIndex
import numpy as np
from collections import defaultdict
import torch.nn.functional as F


def gaussian_filter(img: Tensor) -> Tensor:
    weight = torch.Tensor(
        [[1/16, 1/8, 1/16], [1/8, 1/4, 1/8], [1/16, 1/8, 1/16]]).reshape([1, 3, 3])
    weight = torch.stack([weight, weight, weight])
    kernel = nn.Parameter(weight)
    ret = F.conv2d(img, kernel, padding=1, groups=3)
    return ret


class disjoint_set:  # 并查集

    def __init__(self, nodes):
        self.num = nodes
        self.arr = np.zeros((self.num, 3), dtype=np.int64)

        for i in range(self.num):
            self.arr[i][0] = i
            self.arr[i][1] = 0
            self.arr[i][2] = 1

        self.Int = np.zeros((self.num,), dtype=np.float64)

    def update_Int(self, xp, yp, w):
        new_Int = max(w, self.Int[xp], self.Int[yp])
        self.Int[yp] = new_Int
        self.Int[xp] = new_Int

    def fa(self, x):
        x = int(x)
        if self.arr[x][0] == x:
            return x
        else:
            self.arr[x][0] = self.fa(self.arr[x][0])
            return self.arr[x][0]

    def merge(self, x, y):
        xp = self.fa(x)
        yp = self.fa(y)

        if self.arr[xp][1] < self.arr[yp][1]:
            self.arr[xp][0] = yp
            self.arr[yp][2] += self.arr[xp][2]
        elif self.arr[xp][1] > self.arr[yp][1]:
            self.arr[yp][0] = xp
            self.arr[xp][2] += self.arr[yp][2]
        else:
            self.arr[xp][0] = yp
            self.arr[yp][1] += 1
            self.arr[yp][2] += self.arr[xp][2]

    def is_same_fa(self, x, y):
        return self.fa(x) == self.fa(y)

    def conclusion(self):
        con = defaultdict(list)

        for i in range(self.num):
            con[self.fa(self.arr[i][0])].append(i)

        return con

def unique(x, dim=None):
    """Unique elements of x and indices of those unique elements
    e.g.

    unique(tensor([
        [1, 2, 3],
        [1, 2, 4],
        [1, 2, 3],
        [1, 2, 5]
    ]), dim=0)
    => (tensor([[1, 2, 3],
                [1, 2, 4],
                [1, 2, 5]]),
        tensor([0, 1, 3]))
    """
    unique, inverse = torch.unique(
        x, sorted=True, return_inverse=True, dim=dim)
    perm = torch.arange(inverse.size(0), dtype=inverse.dtype,
                        device=inverse.device)
    inverse, perm = inverse.flip([0]), perm.flip([0])
    return unique, inverse.new_empty(unique.size(0)).scatter_(0, inverse, perm)

def grid_graph(img: Tensor, graph_type="grid", d=10, n_tree=10, search_k=-1):
    img = gaussian_filter(img)
    graphs = []
    rows = img.shape[1]
    cols = img.shape[2]
    num_vertices = rows*cols
    num_edges = (rows-1)*cols+(cols-1)*rows

    if graph_type == "grid":
        for c in range(img.shape[0]):
            edges = torch.zeros((num_edges, 3,))
            index = 0
            for i in range(rows):
                print(i,"   fghjkl")
                for j in range(cols):
                    if j < cols-1:
                        edges[index][0] = i*cols+j
                        edges[index][1] = i*cols+j+1
                        edges[index][2] = torch.abs(img[c][i][j]-img[c][i][j+1])
                        index += 1

                    if i < rows-1:
                        edges[index][0] = i*cols+j
                        edges[index][1] = (i+1)*cols+j
                        edges[index][2] = torch.abs(img[c][i][j]-img[c][i+1][j])
                        index += 1

            edges = edges[edges[:, 2].argsort()]
            graphs.append(edges)

    elif graph_type == "nn":
        f = 5
        t = AnnoyIndex(5, "euclidean")

        nn_graph = []
        rows = img.shape[1]
        cols = img.shape[2]

        for i in range(rows):
            for j in range(cols):
                v = [img[0, i, j], img[1, i, j], img[2, i, j], i, j]
                t.add_item(i*cols+j, v)

        t.build(n_tree)

        for i in range(rows*cols):
            for neighbor in t.get_nns_by_item(i, d):
                if neighbor > 1:
                    nn_graph.append([i, neighbor, t.get_distance(i, neighbor)])
                elif neighbor < i:
                    nn_graph.append([neighbor, i, t.get_distance(i, neighbor)])

        nn_graph = Tensor(nn_graph)
        nn_graph = nn_graph[unique(
            nn_graph[:, :2], dim=0)[1]]
        graphs.append(nn_graph[nn_graph[:, 2].argsort()])

    return graphs


def segmentation(graph, rows, cols, k=300, graph_type="grid"):

    def mint(int_c1, size_c1, int_c2, size_c2, k):
        return min(int_c1+k/size_c1, int_c2+k/size_c2)

    seg_chs = []

    for ch in range(len(graph)):
        seg = disjoint_set(rows*cols)

        for i in range(graph[ch].shape[0]):
            x = graph[ch][i][0]
            y = graph[ch][i][1]
            w = graph[ch][i][2]

            xp = seg.fa(int(x))
            yp = seg.fa(int(y))

            if xp != yp and w < mint(seg.Int[xp], seg.arr[xp][2], seg.Int[yp], seg.arr[yp][2], k):
                seg.merge(xp, yp)
                seg.update_Int(xp, yp, w)

        seg_chs.append(seg)

    return seg_chs


def seg_img(segs, rows, cols, graph_type="grid"):

    img = torch.zeros((3, rows, cols))
    con = None

    if graph_type == "grid":
        con = disjoint_set(rows*cols)

        for i in range(rows):
            for j in range(cols-1):
                x = i*cols+j
                y = i*cols+j+1
                if all([segs[ch].is_same_fa(x, y) for ch in range(len(segs))]):
                    con.merge(x, y)

        for j in range(cols):
            for i in range(rows-1):
                x = i*cols+j
                y = (i+1)*cols+j
                if (all([segs[ch].is_same_fa(x, y) for ch in range(len(segs))])):
                    con.merge(x, y)

    elif graph_type == "nn":

        con = segs[0]

    for i in range(rows):
        for j in range(cols):
            p = con.fa(i*cols+j)
            np.random.seed(p)
            color = Tensor(np.random.randint(256, size=3))
            img[:, i, j] = color

    return img/255

def effecient_segmentation(img: Tensor, graph_type="grid", d=10, n_tree=10, search_k=-1, k=300) -> Tensor:
    p = img.shape[0]

    res = []

    for i in range(p):
        grid = grid_graph(img[i], graph_type, d, n_tree, search_k)
        seg = segmentation(grid, img[i].shape[1],
                           img[i].shape[2], k, graph_type)
        final = seg_img(seg, img[i].shape[1], img[i].shape[2], graph_type)
        res.append(final)

    return torch.stack(res)
