import torch
from torch import Tensor
import torch.nn as nn
from scipy.ndimage import gaussian_filter
from annoy import AnnoyIndex
import numpy as np
from collections import defaultdict


class disjoint_set:  # 并查集

    def __init__(self, nodes):
        self.num = nodes
        self.arr = np.zeros((self.num, 3), dtype=np.int64)

        for i in range(self.num):
            self.arr[i][0] = i
            self.arr[i][1] = 0
            self.arr[i][2] = 1

        self.Int = np.zeros((self.num,), dtype=np.float64)

    def update_Int(self, xp, yp, w):
        new_Int = max(w, self.Int[xp], self.Int[yp])
        self.Int[yp] = new_Int
        self.Int[xp] = new_Int

    def fa(self, x):
        x = int(x)
        if self.arr[x][0] == x:
            return x
        else:
            self.arr[x][0] = self.fa(self.arr[x][0])
            return self.arr[x][0]

    def merge(self, x, y):
        xp = self.fa(x)
        yp = self.fa(y)

        if self.arr[xp][1] < self.arr[yp][1]:
            self.arr[xp][0] = yp
            self.arr[yp][2] += self.arr[xp][2]
        elif self.arr[xp][1] > self.arr[yp][1]:
            self.arr[yp][0] = xp
            self.arr[xp][2] += self.arr[yp][2]
        else:
            self.arr[xp][0] = yp
            self.arr[yp][1] += 1
            self.arr[yp][2] += self.arr[xp][2]

    def is_same_fa(self, x, y):
        return self.fa(x) == self.fa(y)

    def conclusion(self):
        con = defaultdict(list)

        for i in range(self.num):
            con[self.fa(self.arr[i][0])].append(i)

        return con


def chw2hwc(img):
    tmp = np.zeros([img.shape[1], img.shape[2], img.shape[0], ])
    tmp[:, :, 0] = img[0]
    tmp[:, :, 1] = img[1]
    tmp[:, :, 2] = img[2]
    return tmp


def hwc2chw(img):
    tmp = np.zeros([img.shape[2], img.shape[0], img.shape[1]])
    tmp[0] = img[:, :, 0]
    tmp[1] = img[:, :, 1]
    tmp[2] = img[:, :, 2]
    return tmp


def grid_graph(img: Tensor, graph_type="grid", d=10, n_tree=10, search_k=-1):
    img = img.numpy().astype(np.int32)
    img = chw2hwc(img)
    img = gaussian_filter(img, 0.8)
    img = hwc2chw(img)
    graphs = []
    rows = img.shape[1]
    cols = img.shape[2]
    num_vertices = rows*cols
    num_edges = (rows-1)*cols+(cols-1)*rows

    if graph_type == "grid":
        for c in range(img.shape[0]):
            edges = np.zeros((num_edges, 3, ), dtype=np.float64)
            index = 0
            for i in range(rows):
                for j in range(cols):
                    if j < cols-1:
                        edges[index][0] = i*cols+j
                        edges[index][1] = i*cols+j+1
                        edges[index][2] = abs(img[c][i][j]-img[c][i][j+1])
                        index += 1

                    if i < rows-1:
                        edges[index][0] = i*cols+j
                        edges[index][1] = (i+1)*cols+j
                        edges[index][2] = abs(img[c][i][j]-img[c][i+1][j])
                        index += 1

            edges = edges[edges[:, 2].argsort()]
            graphs.append(edges)

    elif graph_type == "nn":
        f = 5
        t = AnnoyIndex(5, "euclidean")

        nn_graph = []
        rows = img.shape[1]
        cols = img.shape[2]

        for i in range(rows):
            for j in range(cols):
                v = [img[0, i, j], img[1, i, j], img[2, i, j], i, j]
                t.add_item(i*cols+j, v)

        t.build(n_tree)

        for i in range(rows*cols):
            for neighbor in t.get_nns_by_item(i, d):
                if neighbor > 1:
                    nn_graph.append([i, neighbor, t.get_distance(i, neighbor)])
                elif neighbor < i:
                    nn_graph.append([neighbor, i, t.get_distance(i, neighbor)])

        nn_graph = np.array(nn_graph)
        nn_graph = nn_graph[np.unique(
            nn_graph[:, :2], axis=0, return_index=True)[1]]
        graphs.append(nn_graph[nn_graph[:, 2].argsort()])

    return graphs


def segmentation(graph, rows, cols, k=300, graph_type="grid"):

    def mint(int_c1, size_c1, int_c2, size_c2, k):
        return min(int_c1+k/size_c1, int_c2+k/size_c2)

    seg_chs = []

    for ch in range(len(graph)):
        seg = disjoint_set(rows*cols)

        for i in range(graph[ch].shape[0]):
            x = graph[ch][i][0]
            y = graph[ch][i][1]
            w = graph[ch][i][2]

            xp = seg.fa(int(x))
            yp = seg.fa(int(y))

            if xp != yp and w < mint(seg.Int[xp], seg.arr[xp][2], seg.Int[yp], seg.arr[yp][2], k):
                seg.merge(xp, yp)
                seg.update_Int(xp, yp, w)

        seg_chs.append(seg)

    return seg_chs


def seg_img(segs, rows, cols, graph_type="grid"):

    img = np.zeros((3, rows, cols), dtype=np.float64)
    con = None

    if graph_type == "grid":
        con = disjoint_set(rows*cols)

        for i in range(rows):
            for j in range(cols-1):
                x = i*cols+j
                y = i*cols+j+1
                if all([segs[ch].is_same_fa(x, y) for ch in range(len(segs))]):
                    con.merge(x, y)

        for j in range(cols):
            for i in range(rows-1):
                x = i*cols+j
                y = (i+1)*cols+j
                if (all([segs[ch].is_same_fa(x, y) for ch in range(len(segs))])):
                    con.merge(x, y)

    elif graph_type == "nn":

        con = segs[0]

    for i in range(rows):
        for j in range(cols):
            p = con.fa(i*cols+j)
            np.random.seed(p)
            color = np.random.randint(256, size=3)
            img[0][i][j] = color[0]
            img[1][i][j] = color[1]
            img[2][i][j] = color[2]

    return img/255


def effecient_segmentation(img: Tensor, graph_type="grid", d=10, n_tree=10, search_k=-1, k=300) -> Tensor:
    p = img.shape[0]

    res = []

    for i in range(p):
        grid = grid_graph(img[i], graph_type, d, n_tree, search_k)
        seg = segmentation(grid, img[i].shape[1],
                           img[i].shape[2], k, graph_type)
        final = seg_img(seg, img[i].shape[1], img[i].shape[2], graph_type)
        res.append(torch.from_numpy(final))

    return torch.stack(res)
